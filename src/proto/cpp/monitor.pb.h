// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: monitor.proto

#ifndef PROTOBUF_monitor_2eproto__INCLUDED
#define PROTOBUF_monitor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "chain.pb.h"
// @@protoc_insertion_point(includes)

namespace monitor {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_monitor_2eproto();
void protobuf_AssignDesc_monitor_2eproto();
void protobuf_ShutdownFile_monitor_2eproto();

class AlertState;
class AlertStatus;
class BubiAttack;
class BubiStatus;
class CPU;
class ChainAlertMessage;
class ErrorMessage;
class GlueManager;
class Hello;
class LedgerStatus;
class Partition;
class Peer;
class PeerManager;
class Register;
class SystemProperty;
class SystemResource;
class SystemStatus;
class Threshold;

enum AlertState_ALERT_TYPE {
  AlertState_ALERT_TYPE_NONE = 0,
  AlertState_ALERT_TYPE_NOWARNING = 1,
  AlertState_ALERT_TYPE_WARNING = 2,
  AlertState_ALERT_TYPE_AlertState_ALERT_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AlertState_ALERT_TYPE_AlertState_ALERT_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AlertState_ALERT_TYPE_IsValid(int value);
const AlertState_ALERT_TYPE AlertState_ALERT_TYPE_ALERT_TYPE_MIN = AlertState_ALERT_TYPE_NONE;
const AlertState_ALERT_TYPE AlertState_ALERT_TYPE_ALERT_TYPE_MAX = AlertState_ALERT_TYPE_WARNING;
const int AlertState_ALERT_TYPE_ALERT_TYPE_ARRAYSIZE = AlertState_ALERT_TYPE_ALERT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlertState_ALERT_TYPE_descriptor();
inline const ::std::string& AlertState_ALERT_TYPE_Name(AlertState_ALERT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlertState_ALERT_TYPE_descriptor(), value);
}
inline bool AlertState_ALERT_TYPE_Parse(
    const ::std::string& name, AlertState_ALERT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlertState_ALERT_TYPE>(
    AlertState_ALERT_TYPE_descriptor(), name, value);
}
enum MONITOR_MESSAGE_TYPE {
  MONITOR_MSGTYPE_NONE = 0,
  MONITOR_MSGTYPE_HELLO = 30,
  MONITOR_MSGTYPE_REGISTER = 31,
  MONITOR_MSGTYPE_BUBI = 32,
  MONITOR_MSGTYPE_LEDGER = 33,
  MONITOR_MSGTYPE_SYSTEM = 34,
  MONITOR_MSGTYPE_ALERT = 35,
  MONITOR_MSGTYPE_NOTICE = 36,
  MONITOR_MSGTYPE_ACCOUNT_EXCEPTION = 37,
  MONITOR_MSGTYPE_ERROR = 39,
  MONITOR_MESSAGE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MONITOR_MESSAGE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MONITOR_MESSAGE_TYPE_IsValid(int value);
const MONITOR_MESSAGE_TYPE MONITOR_MESSAGE_TYPE_MIN = MONITOR_MSGTYPE_NONE;
const MONITOR_MESSAGE_TYPE MONITOR_MESSAGE_TYPE_MAX = MONITOR_MSGTYPE_ERROR;
const int MONITOR_MESSAGE_TYPE_ARRAYSIZE = MONITOR_MESSAGE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MONITOR_MESSAGE_TYPE_descriptor();
inline const ::std::string& MONITOR_MESSAGE_TYPE_Name(MONITOR_MESSAGE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MONITOR_MESSAGE_TYPE_descriptor(), value);
}
inline bool MONITOR_MESSAGE_TYPE_Parse(
    const ::std::string& name, MONITOR_MESSAGE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MONITOR_MESSAGE_TYPE>(
    MONITOR_MESSAGE_TYPE_descriptor(), name, value);
}
enum MONITOR_ERROR {
  MONITOR_INTERNAL_ERROR = 0,
  MONITOR_MESSAGE_NOT_EXIST = 1,
  MONITOR_MISSING_PARAMETER = 2,
  MONITOR_ID_NOT_EXIST = 3,
  MONITOR_ID_ALREAD_EXIST = 4,
  MONITOR_CENTER_INVALID = 5,
  MONITOR_AGENT_INVALID = 6,
  MONITOR_NOT_LOGIN = 7,
  MONITOR_BUBI_MESSAGE_ERROR = 8,
  MONITOR_SYSTEM_MESSAGE_ERROR = 9,
  MONITOR_LEDGER_MESSAGE_ERROR = 10,
  MONITOR_ERROR_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MONITOR_ERROR_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MONITOR_ERROR_IsValid(int value);
const MONITOR_ERROR MONITOR_ERROR_MIN = MONITOR_INTERNAL_ERROR;
const MONITOR_ERROR MONITOR_ERROR_MAX = MONITOR_LEDGER_MESSAGE_ERROR;
const int MONITOR_ERROR_ARRAYSIZE = MONITOR_ERROR_MAX + 1;

const ::google::protobuf::EnumDescriptor* MONITOR_ERROR_descriptor();
inline const ::std::string& MONITOR_ERROR_Name(MONITOR_ERROR value) {
  return ::google::protobuf::internal::NameOfEnum(
    MONITOR_ERROR_descriptor(), value);
}
inline bool MONITOR_ERROR_Parse(
    const ::std::string& name, MONITOR_ERROR* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MONITOR_ERROR>(
    MONITOR_ERROR_descriptor(), name, value);
}
// ===================================================================

class BubiAttack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.BubiAttack) */ {
 public:
  BubiAttack();
  virtual ~BubiAttack();

  BubiAttack(const BubiAttack& from);

  inline BubiAttack& operator=(const BubiAttack& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BubiAttack& default_instance();

  void Swap(BubiAttack* other);

  // implements Message ----------------------------------------------

  inline BubiAttack* New() const { return New(NULL); }

  BubiAttack* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BubiAttack& from);
  void MergeFrom(const BubiAttack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BubiAttack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 bubi_attack_time = 1;
  void clear_bubi_attack_time();
  static const int kBubiAttackTimeFieldNumber = 1;
  ::google::protobuf::uint32 bubi_attack_time() const;
  void set_bubi_attack_time(::google::protobuf::uint32 value);

  // optional uint32 bubi_attack_counts = 2;
  void clear_bubi_attack_counts();
  static const int kBubiAttackCountsFieldNumber = 2;
  ::google::protobuf::uint32 bubi_attack_counts() const;
  void set_bubi_attack_counts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:monitor.BubiAttack)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 bubi_attack_time_;
  ::google::protobuf::uint32 bubi_attack_counts_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static BubiAttack* default_instance_;
};
// -------------------------------------------------------------------

class Threshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Threshold) */ {
 public:
  Threshold();
  virtual ~Threshold();

  Threshold(const Threshold& from);

  inline Threshold& operator=(const Threshold& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Threshold& default_instance();

  void Swap(Threshold* other);

  // implements Message ----------------------------------------------

  inline Threshold* New() const { return New(NULL); }

  Threshold* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Threshold& from);
  void MergeFrom(const Threshold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Threshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float cpu = 1;
  void clear_cpu();
  static const int kCpuFieldNumber = 1;
  float cpu() const;
  void set_cpu(float value);

  // optional float memory = 2;
  void clear_memory();
  static const int kMemoryFieldNumber = 2;
  float memory() const;
  void set_memory(float value);

  // optional float disk = 3;
  void clear_disk();
  static const int kDiskFieldNumber = 3;
  float disk() const;
  void set_disk(float value);

  // optional uint32 consensus_timeout = 4;
  void clear_consensus_timeout();
  static const int kConsensusTimeoutFieldNumber = 4;
  ::google::protobuf::uint32 consensus_timeout() const;
  void set_consensus_timeout(::google::protobuf::uint32 value);

  // optional uint32 bubi_timeout = 5;
  void clear_bubi_timeout();
  static const int kBubiTimeoutFieldNumber = 5;
  ::google::protobuf::uint32 bubi_timeout() const;
  void set_bubi_timeout(::google::protobuf::uint32 value);

  // optional uint32 monitor_timeout = 6;
  void clear_monitor_timeout();
  static const int kMonitorTimeoutFieldNumber = 6;
  ::google::protobuf::uint32 monitor_timeout() const;
  void set_monitor_timeout(::google::protobuf::uint32 value);

  // optional .monitor.BubiAttack bubi_attack = 7;
  bool has_bubi_attack() const;
  void clear_bubi_attack();
  static const int kBubiAttackFieldNumber = 7;
  const ::monitor::BubiAttack& bubi_attack() const;
  ::monitor::BubiAttack* mutable_bubi_attack();
  ::monitor::BubiAttack* release_bubi_attack();
  void set_allocated_bubi_attack(::monitor::BubiAttack* bubi_attack);

  // @@protoc_insertion_point(class_scope:monitor.Threshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float cpu_;
  float memory_;
  float disk_;
  ::google::protobuf::uint32 consensus_timeout_;
  ::google::protobuf::uint32 bubi_timeout_;
  ::google::protobuf::uint32 monitor_timeout_;
  ::monitor::BubiAttack* bubi_attack_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Threshold* default_instance_;
};
// -------------------------------------------------------------------

class Hello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Hello) */ {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  inline Hello* New() const { return New(NULL); }

  Hello* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string blockchain_version = 2;
  void clear_blockchain_version();
  static const int kBlockchainVersionFieldNumber = 2;
  const ::std::string& blockchain_version() const;
  void set_blockchain_version(const ::std::string& value);
  void set_blockchain_version(const char* value);
  void set_blockchain_version(const char* value, size_t size);
  ::std::string* mutable_blockchain_version();
  ::std::string* release_blockchain_version();
  void set_allocated_blockchain_version(::std::string* blockchain_version);

  // optional int64 data_version = 3;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 3;
  ::google::protobuf::int64 data_version() const;
  void set_data_version(::google::protobuf::int64 value);

  // optional int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:monitor.Hello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr blockchain_version_;
  ::google::protobuf::int64 data_version_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Register) */ {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  inline Register* New() const { return New(NULL); }

  Register* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rand_id = 1;
  void clear_rand_id();
  static const int kRandIdFieldNumber = 1;
  const ::std::string& rand_id() const;
  void set_rand_id(const ::std::string& value);
  void set_rand_id(const char* value);
  void set_rand_id(const char* value, size_t size);
  ::std::string* mutable_rand_id();
  ::std::string* release_rand_id();
  void set_allocated_rand_id(::std::string* rand_id);

  // optional string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional .monitor.Threshold threshold = 5;
  bool has_threshold() const;
  void clear_threshold();
  static const int kThresholdFieldNumber = 5;
  const ::monitor::Threshold& threshold() const;
  ::monitor::Threshold* mutable_threshold();
  ::monitor::Threshold* release_threshold();
  void set_allocated_threshold(::monitor::Threshold* threshold);

  // @@protoc_insertion_point(class_scope:monitor.Register)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr rand_id_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::int64 timestamp_;
  ::monitor::Threshold* threshold_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class ErrorMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.ErrorMessage) */ {
 public:
  ErrorMessage();
  virtual ~ErrorMessage();

  ErrorMessage(const ErrorMessage& from);

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorMessage& default_instance();

  void Swap(ErrorMessage* other);

  // implements Message ----------------------------------------------

  inline ErrorMessage* New() const { return New(NULL); }

  ErrorMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorMessage& from);
  void MergeFrom(const ErrorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .monitor.MONITOR_ERROR error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::monitor::MONITOR_ERROR error_code() const;
  void set_error_code(::monitor::MONITOR_ERROR value);

  // optional string desception = 2;
  void clear_desception();
  static const int kDesceptionFieldNumber = 2;
  const ::std::string& desception() const;
  void set_desception(const ::std::string& value);
  void set_desception(const char* value);
  void set_desception(const char* value, size_t size);
  ::std::string* mutable_desception();
  ::std::string* release_desception();
  void set_allocated_desception(::std::string* desception);

  // optional int64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:monitor.ErrorMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr desception_;
  ::google::protobuf::int64 timestamp_;
  int error_code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static ErrorMessage* default_instance_;
};
// -------------------------------------------------------------------

class Peer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Peer) */ {
 public:
  Peer();
  virtual ~Peer();

  Peer(const Peer& from);

  inline Peer& operator=(const Peer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Peer& default_instance();

  void Swap(Peer* other);

  // implements Message ----------------------------------------------

  inline Peer* New() const { return New(NULL); }

  Peer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Peer& from);
  void MergeFrom(const Peer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Peer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional int64 delay = 2;
  void clear_delay();
  static const int kDelayFieldNumber = 2;
  ::google::protobuf::int64 delay() const;
  void set_delay(::google::protobuf::int64 value);

  // optional bool active = 3;
  void clear_active();
  static const int kActiveFieldNumber = 3;
  bool active() const;
  void set_active(bool value);

  // optional string ip_address = 4;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 4;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // @@protoc_insertion_point(class_scope:monitor.Peer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::int64 delay_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  bool active_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Peer* default_instance_;
};
// -------------------------------------------------------------------

class GlueManager : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.GlueManager) */ {
 public:
  GlueManager();
  virtual ~GlueManager();

  GlueManager(const GlueManager& from);

  inline GlueManager& operator=(const GlueManager& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlueManager& default_instance();

  void Swap(GlueManager* other);

  // implements Message ----------------------------------------------

  inline GlueManager* New() const { return New(NULL); }

  GlueManager* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlueManager& from);
  void MergeFrom(const GlueManager& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GlueManager* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string system_current_time = 1;
  void clear_system_current_time();
  static const int kSystemCurrentTimeFieldNumber = 1;
  const ::std::string& system_current_time() const;
  void set_system_current_time(const ::std::string& value);
  void set_system_current_time(const char* value);
  void set_system_current_time(const char* value, size_t size);
  ::std::string* mutable_system_current_time();
  ::std::string* release_system_current_time();
  void set_allocated_system_current_time(::std::string* system_current_time);

  // optional string process_uptime = 2;
  void clear_process_uptime();
  static const int kProcessUptimeFieldNumber = 2;
  const ::std::string& process_uptime() const;
  void set_process_uptime(const ::std::string& value);
  void set_process_uptime(const char* value);
  void set_process_uptime(const char* value, size_t size);
  ::std::string* mutable_process_uptime();
  ::std::string* release_process_uptime();
  void set_allocated_process_uptime(::std::string* process_uptime);

  // optional string system_uptime = 3;
  void clear_system_uptime();
  static const int kSystemUptimeFieldNumber = 3;
  const ::std::string& system_uptime() const;
  void set_system_uptime(const ::std::string& value);
  void set_system_uptime(const char* value);
  void set_system_uptime(const char* value, size_t size);
  ::std::string* mutable_system_uptime();
  ::std::string* release_system_uptime();
  void set_allocated_system_uptime(::std::string* system_uptime);

  // @@protoc_insertion_point(class_scope:monitor.GlueManager)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr system_current_time_;
  ::google::protobuf::internal::ArenaStringPtr process_uptime_;
  ::google::protobuf::internal::ArenaStringPtr system_uptime_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static GlueManager* default_instance_;
};
// -------------------------------------------------------------------

class PeerManager : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.PeerManager) */ {
 public:
  PeerManager();
  virtual ~PeerManager();

  PeerManager(const PeerManager& from);

  inline PeerManager& operator=(const PeerManager& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerManager& default_instance();

  void Swap(PeerManager* other);

  // implements Message ----------------------------------------------

  inline PeerManager* New() const { return New(NULL); }

  PeerManager* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerManager& from);
  void MergeFrom(const PeerManager& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeerManager* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string peer_id = 1;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  const ::std::string& peer_id() const;
  void set_peer_id(const ::std::string& value);
  void set_peer_id(const char* value);
  void set_peer_id(const char* value, size_t size);
  ::std::string* mutable_peer_id();
  ::std::string* release_peer_id();
  void set_allocated_peer_id(::std::string* peer_id);

  // repeated .monitor.Peer peer = 2;
  int peer_size() const;
  void clear_peer();
  static const int kPeerFieldNumber = 2;
  const ::monitor::Peer& peer(int index) const;
  ::monitor::Peer* mutable_peer(int index);
  ::monitor::Peer* add_peer();
  ::google::protobuf::RepeatedPtrField< ::monitor::Peer >*
      mutable_peer();
  const ::google::protobuf::RepeatedPtrField< ::monitor::Peer >&
      peer() const;

  // @@protoc_insertion_point(class_scope:monitor.PeerManager)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr peer_id_;
  ::google::protobuf::RepeatedPtrField< ::monitor::Peer > peer_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static PeerManager* default_instance_;
};
// -------------------------------------------------------------------

class BubiStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.BubiStatus) */ {
 public:
  BubiStatus();
  virtual ~BubiStatus();

  BubiStatus(const BubiStatus& from);

  inline BubiStatus& operator=(const BubiStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BubiStatus& default_instance();

  void Swap(BubiStatus* other);

  // implements Message ----------------------------------------------

  inline BubiStatus* New() const { return New(NULL); }

  BubiStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BubiStatus& from);
  void MergeFrom(const BubiStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BubiStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .monitor.GlueManager glue_manager = 1;
  bool has_glue_manager() const;
  void clear_glue_manager();
  static const int kGlueManagerFieldNumber = 1;
  const ::monitor::GlueManager& glue_manager() const;
  ::monitor::GlueManager* mutable_glue_manager();
  ::monitor::GlueManager* release_glue_manager();
  void set_allocated_glue_manager(::monitor::GlueManager* glue_manager);

  // optional .monitor.PeerManager peer_manager = 2;
  bool has_peer_manager() const;
  void clear_peer_manager();
  static const int kPeerManagerFieldNumber = 2;
  const ::monitor::PeerManager& peer_manager() const;
  ::monitor::PeerManager* mutable_peer_manager();
  ::monitor::PeerManager* release_peer_manager();
  void set_allocated_peer_manager(::monitor::PeerManager* peer_manager);

  // @@protoc_insertion_point(class_scope:monitor.BubiStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::monitor::GlueManager* glue_manager_;
  ::monitor::PeerManager* peer_manager_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static BubiStatus* default_instance_;
};
// -------------------------------------------------------------------

class LedgerStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.LedgerStatus) */ {
 public:
  LedgerStatus();
  virtual ~LedgerStatus();

  LedgerStatus(const LedgerStatus& from);

  inline LedgerStatus& operator=(const LedgerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerStatus& default_instance();

  void Swap(LedgerStatus* other);

  // implements Message ----------------------------------------------

  inline LedgerStatus* New() const { return New(NULL); }

  LedgerStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LedgerStatus& from);
  void MergeFrom(const LedgerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LedgerStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.LedgerHeader ledger_header = 1;
  bool has_ledger_header() const;
  void clear_ledger_header();
  static const int kLedgerHeaderFieldNumber = 1;
  const ::protocol::LedgerHeader& ledger_header() const;
  ::protocol::LedgerHeader* mutable_ledger_header();
  ::protocol::LedgerHeader* release_ledger_header();
  void set_allocated_ledger_header(::protocol::LedgerHeader* ledger_header);

  // optional int64 transaction_size = 2;
  void clear_transaction_size();
  static const int kTransactionSizeFieldNumber = 2;
  ::google::protobuf::int64 transaction_size() const;
  void set_transaction_size(::google::protobuf::int64 value);

  // optional int64 account_count = 3;
  void clear_account_count();
  static const int kAccountCountFieldNumber = 3;
  ::google::protobuf::int64 account_count() const;
  void set_account_count(::google::protobuf::int64 value);

  // optional int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:monitor.LedgerStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::LedgerHeader* ledger_header_;
  ::google::protobuf::int64 transaction_size_;
  ::google::protobuf::int64 account_count_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static LedgerStatus* default_instance_;
};
// -------------------------------------------------------------------

class SystemProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.SystemProperty) */ {
 public:
  SystemProperty();
  virtual ~SystemProperty();

  SystemProperty(const SystemProperty& from);

  inline SystemProperty& operator=(const SystemProperty& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemProperty& default_instance();

  void Swap(SystemProperty* other);

  // implements Message ----------------------------------------------

  inline SystemProperty* New() const { return New(NULL); }

  SystemProperty* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemProperty& from);
  void MergeFrom(const SystemProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string host_name = 1;
  void clear_host_name();
  static const int kHostNameFieldNumber = 1;
  const ::std::string& host_name() const;
  void set_host_name(const ::std::string& value);
  void set_host_name(const char* value);
  void set_host_name(const char* value, size_t size);
  ::std::string* mutable_host_name();
  ::std::string* release_host_name();
  void set_allocated_host_name(::std::string* host_name);

  // optional string os_version = 2;
  void clear_os_version();
  static const int kOsVersionFieldNumber = 2;
  const ::std::string& os_version() const;
  void set_os_version(const ::std::string& value);
  void set_os_version(const char* value);
  void set_os_version(const char* value, size_t size);
  ::std::string* mutable_os_version();
  ::std::string* release_os_version();
  void set_allocated_os_version(::std::string* os_version);

  // optional int64 startup_time = 3;
  void clear_startup_time();
  static const int kStartupTimeFieldNumber = 3;
  ::google::protobuf::int64 startup_time() const;
  void set_startup_time(::google::protobuf::int64 value);

  // optional string os_bit = 4;
  void clear_os_bit();
  static const int kOsBitFieldNumber = 4;
  const ::std::string& os_bit() const;
  void set_os_bit(const ::std::string& value);
  void set_os_bit(const char* value);
  void set_os_bit(const char* value, size_t size);
  ::std::string* mutable_os_bit();
  ::std::string* release_os_bit();
  void set_allocated_os_bit(::std::string* os_bit);

  // @@protoc_insertion_point(class_scope:monitor.SystemProperty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr host_name_;
  ::google::protobuf::internal::ArenaStringPtr os_version_;
  ::google::protobuf::int64 startup_time_;
  ::google::protobuf::internal::ArenaStringPtr os_bit_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static SystemProperty* default_instance_;
};
// -------------------------------------------------------------------

class SystemResource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.SystemResource) */ {
 public:
  SystemResource();
  virtual ~SystemResource();

  SystemResource(const SystemResource& from);

  inline SystemResource& operator=(const SystemResource& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemResource& default_instance();

  void Swap(SystemResource* other);

  // implements Message ----------------------------------------------

  inline SystemResource* New() const { return New(NULL); }

  SystemResource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemResource& from);
  void MergeFrom(const SystemResource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemResource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 available = 1;
  void clear_available();
  static const int kAvailableFieldNumber = 1;
  ::google::protobuf::int64 available() const;
  void set_available(::google::protobuf::int64 value);

  // optional int64 total = 2;
  void clear_total();
  static const int kTotalFieldNumber = 2;
  ::google::protobuf::int64 total() const;
  void set_total(::google::protobuf::int64 value);

  // optional double usedPercent = 3;
  void clear_usedpercent();
  static const int kUsedPercentFieldNumber = 3;
  double usedpercent() const;
  void set_usedpercent(double value);

  // optional string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:monitor.SystemResource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 available_;
  ::google::protobuf::int64 total_;
  double usedpercent_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static SystemResource* default_instance_;
};
// -------------------------------------------------------------------

class Partition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Partition) */ {
 public:
  Partition();
  virtual ~Partition();

  Partition(const Partition& from);

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Partition& default_instance();

  void Swap(Partition* other);

  // implements Message ----------------------------------------------

  inline Partition* New() const { return New(NULL); }

  Partition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Partition& from);
  void MergeFrom(const Partition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Partition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 total_bytes = 1;
  void clear_total_bytes();
  static const int kTotalBytesFieldNumber = 1;
  ::google::protobuf::int64 total_bytes() const;
  void set_total_bytes(::google::protobuf::int64 value);

  // repeated .monitor.SystemResource partition = 2;
  int partition_size() const;
  void clear_partition();
  static const int kPartitionFieldNumber = 2;
  const ::monitor::SystemResource& partition(int index) const;
  ::monitor::SystemResource* mutable_partition(int index);
  ::monitor::SystemResource* add_partition();
  ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >*
      mutable_partition();
  const ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >&
      partition() const;

  // @@protoc_insertion_point(class_scope:monitor.Partition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 total_bytes_;
  ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource > partition_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Partition* default_instance_;
};
// -------------------------------------------------------------------

class CPU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.CPU) */ {
 public:
  CPU();
  virtual ~CPU();

  CPU(const CPU& from);

  inline CPU& operator=(const CPU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPU& default_instance();

  void Swap(CPU* other);

  // implements Message ----------------------------------------------

  inline CPU* New() const { return New(NULL); }

  CPU* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPU& from);
  void MergeFrom(const CPU& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CPU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double usedPercent = 1;
  void clear_usedpercent();
  static const int kUsedPercentFieldNumber = 1;
  double usedpercent() const;
  void set_usedpercent(double value);

  // @@protoc_insertion_point(class_scope:monitor.CPU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double usedpercent_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static CPU* default_instance_;
};
// -------------------------------------------------------------------

class SystemStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.SystemStatus) */ {
 public:
  SystemStatus();
  virtual ~SystemStatus();

  SystemStatus(const SystemStatus& from);

  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemStatus& default_instance();

  void Swap(SystemStatus* other);

  // implements Message ----------------------------------------------

  inline SystemStatus* New() const { return New(NULL); }

  SystemStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemStatus& from);
  void MergeFrom(const SystemStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .monitor.SystemProperty property = 1;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 1;
  const ::monitor::SystemProperty& property() const;
  ::monitor::SystemProperty* mutable_property();
  ::monitor::SystemProperty* release_property();
  void set_allocated_property(::monitor::SystemProperty* property);

  // optional .monitor.SystemResource memory = 2;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 2;
  const ::monitor::SystemResource& memory() const;
  ::monitor::SystemResource* mutable_memory();
  ::monitor::SystemResource* release_memory();
  void set_allocated_memory(::monitor::SystemResource* memory);

  // optional .monitor.CPU cpu = 3;
  bool has_cpu() const;
  void clear_cpu();
  static const int kCpuFieldNumber = 3;
  const ::monitor::CPU& cpu() const;
  ::monitor::CPU* mutable_cpu();
  ::monitor::CPU* release_cpu();
  void set_allocated_cpu(::monitor::CPU* cpu);

  // optional .monitor.Partition partitions = 4;
  bool has_partitions() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 4;
  const ::monitor::Partition& partitions() const;
  ::monitor::Partition* mutable_partitions();
  ::monitor::Partition* release_partitions();
  void set_allocated_partitions(::monitor::Partition* partitions);

  // @@protoc_insertion_point(class_scope:monitor.SystemStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::monitor::SystemProperty* property_;
  ::monitor::SystemResource* memory_;
  ::monitor::CPU* cpu_;
  ::monitor::Partition* partitions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static SystemStatus* default_instance_;
};
// -------------------------------------------------------------------

class AlertState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.AlertState) */ {
 public:
  AlertState();
  virtual ~AlertState();

  AlertState(const AlertState& from);

  inline AlertState& operator=(const AlertState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertState& default_instance();

  void Swap(AlertState* other);

  // implements Message ----------------------------------------------

  inline AlertState* New() const { return New(NULL); }

  AlertState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertState& from);
  void MergeFrom(const AlertState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AlertState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AlertState_ALERT_TYPE ALERT_TYPE;
  static const ALERT_TYPE NONE =
    AlertState_ALERT_TYPE_NONE;
  static const ALERT_TYPE NOWARNING =
    AlertState_ALERT_TYPE_NOWARNING;
  static const ALERT_TYPE WARNING =
    AlertState_ALERT_TYPE_WARNING;
  static inline bool ALERT_TYPE_IsValid(int value) {
    return AlertState_ALERT_TYPE_IsValid(value);
  }
  static const ALERT_TYPE ALERT_TYPE_MIN =
    AlertState_ALERT_TYPE_ALERT_TYPE_MIN;
  static const ALERT_TYPE ALERT_TYPE_MAX =
    AlertState_ALERT_TYPE_ALERT_TYPE_MAX;
  static const int ALERT_TYPE_ARRAYSIZE =
    AlertState_ALERT_TYPE_ALERT_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ALERT_TYPE_descriptor() {
    return AlertState_ALERT_TYPE_descriptor();
  }
  static inline const ::std::string& ALERT_TYPE_Name(ALERT_TYPE value) {
    return AlertState_ALERT_TYPE_Name(value);
  }
  static inline bool ALERT_TYPE_Parse(const ::std::string& name,
      ALERT_TYPE* value) {
    return AlertState_ALERT_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .monitor.AlertState.ALERT_TYPE alert_state = 1;
  void clear_alert_state();
  static const int kAlertStateFieldNumber = 1;
  ::monitor::AlertState_ALERT_TYPE alert_state() const;
  void set_alert_state(::monitor::AlertState_ALERT_TYPE value);

  // optional double value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // optional string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:monitor.AlertState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double value_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  int alert_state_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static AlertState* default_instance_;
};
// -------------------------------------------------------------------

class AlertStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.AlertStatus) */ {
 public:
  AlertStatus();
  virtual ~AlertStatus();

  AlertStatus(const AlertStatus& from);

  inline AlertStatus& operator=(const AlertStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertStatus& default_instance();

  void Swap(AlertStatus* other);

  // implements Message ----------------------------------------------

  inline AlertStatus* New() const { return New(NULL); }

  AlertStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertStatus& from);
  void MergeFrom(const AlertStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AlertStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // repeated .monitor.AlertState alert_state = 2;
  int alert_state_size() const;
  void clear_alert_state();
  static const int kAlertStateFieldNumber = 2;
  const ::monitor::AlertState& alert_state(int index) const;
  ::monitor::AlertState* mutable_alert_state(int index);
  ::monitor::AlertState* add_alert_state();
  ::google::protobuf::RepeatedPtrField< ::monitor::AlertState >*
      mutable_alert_state();
  const ::google::protobuf::RepeatedPtrField< ::monitor::AlertState >&
      alert_state() const;

  // @@protoc_insertion_point(class_scope:monitor.AlertStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::monitor::AlertState > alert_state_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static AlertStatus* default_instance_;
};
// -------------------------------------------------------------------

class ChainAlertMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.ChainAlertMessage) */ {
 public:
  ChainAlertMessage();
  virtual ~ChainAlertMessage();

  ChainAlertMessage(const ChainAlertMessage& from);

  inline ChainAlertMessage& operator=(const ChainAlertMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainAlertMessage& default_instance();

  void Swap(ChainAlertMessage* other);

  // implements Message ----------------------------------------------

  inline ChainAlertMessage* New() const { return New(NULL); }

  ChainAlertMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainAlertMessage& from);
  void MergeFrom(const ChainAlertMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainAlertMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 ledger_sequence = 2;
  void clear_ledger_sequence();
  static const int kLedgerSequenceFieldNumber = 2;
  ::google::protobuf::int64 ledger_sequence() const;
  void set_ledger_sequence(::google::protobuf::int64 value);

  // optional string node_id = 3;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // optional .monitor.SystemStatus system = 4;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 4;
  const ::monitor::SystemStatus& system() const;
  ::monitor::SystemStatus* mutable_system();
  ::monitor::SystemStatus* release_system();
  void set_allocated_system(::monitor::SystemStatus* system);

  // @@protoc_insertion_point(class_scope:monitor.ChainAlertMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 ledger_sequence_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::monitor::SystemStatus* system_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static ChainAlertMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BubiAttack

// optional uint32 bubi_attack_time = 1;
inline void BubiAttack::clear_bubi_attack_time() {
  bubi_attack_time_ = 0u;
}
inline ::google::protobuf::uint32 BubiAttack::bubi_attack_time() const {
  // @@protoc_insertion_point(field_get:monitor.BubiAttack.bubi_attack_time)
  return bubi_attack_time_;
}
inline void BubiAttack::set_bubi_attack_time(::google::protobuf::uint32 value) {
  
  bubi_attack_time_ = value;
  // @@protoc_insertion_point(field_set:monitor.BubiAttack.bubi_attack_time)
}

// optional uint32 bubi_attack_counts = 2;
inline void BubiAttack::clear_bubi_attack_counts() {
  bubi_attack_counts_ = 0u;
}
inline ::google::protobuf::uint32 BubiAttack::bubi_attack_counts() const {
  // @@protoc_insertion_point(field_get:monitor.BubiAttack.bubi_attack_counts)
  return bubi_attack_counts_;
}
inline void BubiAttack::set_bubi_attack_counts(::google::protobuf::uint32 value) {
  
  bubi_attack_counts_ = value;
  // @@protoc_insertion_point(field_set:monitor.BubiAttack.bubi_attack_counts)
}

// -------------------------------------------------------------------

// Threshold

// optional float cpu = 1;
inline void Threshold::clear_cpu() {
  cpu_ = 0;
}
inline float Threshold::cpu() const {
  // @@protoc_insertion_point(field_get:monitor.Threshold.cpu)
  return cpu_;
}
inline void Threshold::set_cpu(float value) {
  
  cpu_ = value;
  // @@protoc_insertion_point(field_set:monitor.Threshold.cpu)
}

// optional float memory = 2;
inline void Threshold::clear_memory() {
  memory_ = 0;
}
inline float Threshold::memory() const {
  // @@protoc_insertion_point(field_get:monitor.Threshold.memory)
  return memory_;
}
inline void Threshold::set_memory(float value) {
  
  memory_ = value;
  // @@protoc_insertion_point(field_set:monitor.Threshold.memory)
}

// optional float disk = 3;
inline void Threshold::clear_disk() {
  disk_ = 0;
}
inline float Threshold::disk() const {
  // @@protoc_insertion_point(field_get:monitor.Threshold.disk)
  return disk_;
}
inline void Threshold::set_disk(float value) {
  
  disk_ = value;
  // @@protoc_insertion_point(field_set:monitor.Threshold.disk)
}

// optional uint32 consensus_timeout = 4;
inline void Threshold::clear_consensus_timeout() {
  consensus_timeout_ = 0u;
}
inline ::google::protobuf::uint32 Threshold::consensus_timeout() const {
  // @@protoc_insertion_point(field_get:monitor.Threshold.consensus_timeout)
  return consensus_timeout_;
}
inline void Threshold::set_consensus_timeout(::google::protobuf::uint32 value) {
  
  consensus_timeout_ = value;
  // @@protoc_insertion_point(field_set:monitor.Threshold.consensus_timeout)
}

// optional uint32 bubi_timeout = 5;
inline void Threshold::clear_bubi_timeout() {
  bubi_timeout_ = 0u;
}
inline ::google::protobuf::uint32 Threshold::bubi_timeout() const {
  // @@protoc_insertion_point(field_get:monitor.Threshold.bubi_timeout)
  return bubi_timeout_;
}
inline void Threshold::set_bubi_timeout(::google::protobuf::uint32 value) {
  
  bubi_timeout_ = value;
  // @@protoc_insertion_point(field_set:monitor.Threshold.bubi_timeout)
}

// optional uint32 monitor_timeout = 6;
inline void Threshold::clear_monitor_timeout() {
  monitor_timeout_ = 0u;
}
inline ::google::protobuf::uint32 Threshold::monitor_timeout() const {
  // @@protoc_insertion_point(field_get:monitor.Threshold.monitor_timeout)
  return monitor_timeout_;
}
inline void Threshold::set_monitor_timeout(::google::protobuf::uint32 value) {
  
  monitor_timeout_ = value;
  // @@protoc_insertion_point(field_set:monitor.Threshold.monitor_timeout)
}

// optional .monitor.BubiAttack bubi_attack = 7;
inline bool Threshold::has_bubi_attack() const {
  return !_is_default_instance_ && bubi_attack_ != NULL;
}
inline void Threshold::clear_bubi_attack() {
  if (GetArenaNoVirtual() == NULL && bubi_attack_ != NULL) delete bubi_attack_;
  bubi_attack_ = NULL;
}
inline const ::monitor::BubiAttack& Threshold::bubi_attack() const {
  // @@protoc_insertion_point(field_get:monitor.Threshold.bubi_attack)
  return bubi_attack_ != NULL ? *bubi_attack_ : *default_instance_->bubi_attack_;
}
inline ::monitor::BubiAttack* Threshold::mutable_bubi_attack() {
  
  if (bubi_attack_ == NULL) {
    bubi_attack_ = new ::monitor::BubiAttack;
  }
  // @@protoc_insertion_point(field_mutable:monitor.Threshold.bubi_attack)
  return bubi_attack_;
}
inline ::monitor::BubiAttack* Threshold::release_bubi_attack() {
  // @@protoc_insertion_point(field_release:monitor.Threshold.bubi_attack)
  
  ::monitor::BubiAttack* temp = bubi_attack_;
  bubi_attack_ = NULL;
  return temp;
}
inline void Threshold::set_allocated_bubi_attack(::monitor::BubiAttack* bubi_attack) {
  delete bubi_attack_;
  bubi_attack_ = bubi_attack;
  if (bubi_attack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.Threshold.bubi_attack)
}

// -------------------------------------------------------------------

// Hello

// optional string id = 1;
inline void Hello::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hello::id() const {
  // @@protoc_insertion_point(field_get:monitor.Hello.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Hello.id)
}
inline void Hello::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Hello.id)
}
inline void Hello::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Hello.id)
}
inline ::std::string* Hello::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Hello.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_id() {
  // @@protoc_insertion_point(field_release:monitor.Hello.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:monitor.Hello.id)
}

// optional string blockchain_version = 2;
inline void Hello::clear_blockchain_version() {
  blockchain_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hello::blockchain_version() const {
  // @@protoc_insertion_point(field_get:monitor.Hello.blockchain_version)
  return blockchain_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_blockchain_version(const ::std::string& value) {
  
  blockchain_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Hello.blockchain_version)
}
inline void Hello::set_blockchain_version(const char* value) {
  
  blockchain_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Hello.blockchain_version)
}
inline void Hello::set_blockchain_version(const char* value, size_t size) {
  
  blockchain_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Hello.blockchain_version)
}
inline ::std::string* Hello::mutable_blockchain_version() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Hello.blockchain_version)
  return blockchain_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_blockchain_version() {
  // @@protoc_insertion_point(field_release:monitor.Hello.blockchain_version)
  
  return blockchain_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_blockchain_version(::std::string* blockchain_version) {
  if (blockchain_version != NULL) {
    
  } else {
    
  }
  blockchain_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockchain_version);
  // @@protoc_insertion_point(field_set_allocated:monitor.Hello.blockchain_version)
}

// optional int64 data_version = 3;
inline void Hello::clear_data_version() {
  data_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::data_version() const {
  // @@protoc_insertion_point(field_get:monitor.Hello.data_version)
  return data_version_;
}
inline void Hello::set_data_version(::google::protobuf::int64 value) {
  
  data_version_ = value;
  // @@protoc_insertion_point(field_set:monitor.Hello.data_version)
}

// optional int64 timestamp = 4;
inline void Hello::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.Hello.timestamp)
  return timestamp_;
}
inline void Hello::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.Hello.timestamp)
}

// -------------------------------------------------------------------

// Register

// optional string rand_id = 1;
inline void Register::clear_rand_id() {
  rand_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::rand_id() const {
  // @@protoc_insertion_point(field_get:monitor.Register.rand_id)
  return rand_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_rand_id(const ::std::string& value) {
  
  rand_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Register.rand_id)
}
inline void Register::set_rand_id(const char* value) {
  
  rand_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Register.rand_id)
}
inline void Register::set_rand_id(const char* value, size_t size) {
  
  rand_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Register.rand_id)
}
inline ::std::string* Register::mutable_rand_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Register.rand_id)
  return rand_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_rand_id() {
  // @@protoc_insertion_point(field_release:monitor.Register.rand_id)
  
  return rand_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_rand_id(::std::string* rand_id) {
  if (rand_id != NULL) {
    
  } else {
    
  }
  rand_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rand_id);
  // @@protoc_insertion_point(field_set_allocated:monitor.Register.rand_id)
}

// optional string session_id = 2;
inline void Register::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::session_id() const {
  // @@protoc_insertion_point(field_get:monitor.Register.session_id)
  return session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Register.session_id)
}
inline void Register::set_session_id(const char* value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Register.session_id)
}
inline void Register::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Register.session_id)
}
inline ::std::string* Register::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Register.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_session_id() {
  // @@protoc_insertion_point(field_release:monitor.Register.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:monitor.Register.session_id)
}

// optional string version = 3;
inline void Register::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::version() const {
  // @@protoc_insertion_point(field_get:monitor.Register.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Register.version)
}
inline void Register::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Register.version)
}
inline void Register::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Register.version)
}
inline ::std::string* Register::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Register.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_version() {
  // @@protoc_insertion_point(field_release:monitor.Register.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:monitor.Register.version)
}

// optional int64 timestamp = 4;
inline void Register::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Register::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.Register.timestamp)
  return timestamp_;
}
inline void Register::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.Register.timestamp)
}

// optional .monitor.Threshold threshold = 5;
inline bool Register::has_threshold() const {
  return !_is_default_instance_ && threshold_ != NULL;
}
inline void Register::clear_threshold() {
  if (GetArenaNoVirtual() == NULL && threshold_ != NULL) delete threshold_;
  threshold_ = NULL;
}
inline const ::monitor::Threshold& Register::threshold() const {
  // @@protoc_insertion_point(field_get:monitor.Register.threshold)
  return threshold_ != NULL ? *threshold_ : *default_instance_->threshold_;
}
inline ::monitor::Threshold* Register::mutable_threshold() {
  
  if (threshold_ == NULL) {
    threshold_ = new ::monitor::Threshold;
  }
  // @@protoc_insertion_point(field_mutable:monitor.Register.threshold)
  return threshold_;
}
inline ::monitor::Threshold* Register::release_threshold() {
  // @@protoc_insertion_point(field_release:monitor.Register.threshold)
  
  ::monitor::Threshold* temp = threshold_;
  threshold_ = NULL;
  return temp;
}
inline void Register::set_allocated_threshold(::monitor::Threshold* threshold) {
  delete threshold_;
  threshold_ = threshold;
  if (threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.Register.threshold)
}

// -------------------------------------------------------------------

// ErrorMessage

// optional .monitor.MONITOR_ERROR error_code = 1;
inline void ErrorMessage::clear_error_code() {
  error_code_ = 0;
}
inline ::monitor::MONITOR_ERROR ErrorMessage::error_code() const {
  // @@protoc_insertion_point(field_get:monitor.ErrorMessage.error_code)
  return static_cast< ::monitor::MONITOR_ERROR >(error_code_);
}
inline void ErrorMessage::set_error_code(::monitor::MONITOR_ERROR value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:monitor.ErrorMessage.error_code)
}

// optional string desception = 2;
inline void ErrorMessage::clear_desception() {
  desception_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ErrorMessage::desception() const {
  // @@protoc_insertion_point(field_get:monitor.ErrorMessage.desception)
  return desception_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorMessage::set_desception(const ::std::string& value) {
  
  desception_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.ErrorMessage.desception)
}
inline void ErrorMessage::set_desception(const char* value) {
  
  desception_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.ErrorMessage.desception)
}
inline void ErrorMessage::set_desception(const char* value, size_t size) {
  
  desception_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.ErrorMessage.desception)
}
inline ::std::string* ErrorMessage::mutable_desception() {
  
  // @@protoc_insertion_point(field_mutable:monitor.ErrorMessage.desception)
  return desception_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorMessage::release_desception() {
  // @@protoc_insertion_point(field_release:monitor.ErrorMessage.desception)
  
  return desception_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorMessage::set_allocated_desception(::std::string* desception) {
  if (desception != NULL) {
    
  } else {
    
  }
  desception_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desception);
  // @@protoc_insertion_point(field_set_allocated:monitor.ErrorMessage.desception)
}

// optional int64 timestamp = 3;
inline void ErrorMessage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ErrorMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.ErrorMessage.timestamp)
  return timestamp_;
}
inline void ErrorMessage::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.ErrorMessage.timestamp)
}

// -------------------------------------------------------------------

// Peer

// optional string id = 1;
inline void Peer::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Peer::id() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Peer.id)
}
inline void Peer::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Peer.id)
}
inline void Peer::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Peer.id)
}
inline ::std::string* Peer::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Peer.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_id() {
  // @@protoc_insertion_point(field_release:monitor.Peer.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:monitor.Peer.id)
}

// optional int64 delay = 2;
inline void Peer::clear_delay() {
  delay_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Peer::delay() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.delay)
  return delay_;
}
inline void Peer::set_delay(::google::protobuf::int64 value) {
  
  delay_ = value;
  // @@protoc_insertion_point(field_set:monitor.Peer.delay)
}

// optional bool active = 3;
inline void Peer::clear_active() {
  active_ = false;
}
inline bool Peer::active() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.active)
  return active_;
}
inline void Peer::set_active(bool value) {
  
  active_ = value;
  // @@protoc_insertion_point(field_set:monitor.Peer.active)
}

// optional string ip_address = 4;
inline void Peer::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Peer::ip_address() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.ip_address)
  return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Peer.ip_address)
}
inline void Peer::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Peer.ip_address)
}
inline void Peer::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Peer.ip_address)
}
inline ::std::string* Peer::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Peer.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_ip_address() {
  // @@protoc_insertion_point(field_release:monitor.Peer.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:monitor.Peer.ip_address)
}

// -------------------------------------------------------------------

// GlueManager

// optional string system_current_time = 1;
inline void GlueManager::clear_system_current_time() {
  system_current_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GlueManager::system_current_time() const {
  // @@protoc_insertion_point(field_get:monitor.GlueManager.system_current_time)
  return system_current_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_system_current_time(const ::std::string& value) {
  
  system_current_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.GlueManager.system_current_time)
}
inline void GlueManager::set_system_current_time(const char* value) {
  
  system_current_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.GlueManager.system_current_time)
}
inline void GlueManager::set_system_current_time(const char* value, size_t size) {
  
  system_current_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.GlueManager.system_current_time)
}
inline ::std::string* GlueManager::mutable_system_current_time() {
  
  // @@protoc_insertion_point(field_mutable:monitor.GlueManager.system_current_time)
  return system_current_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GlueManager::release_system_current_time() {
  // @@protoc_insertion_point(field_release:monitor.GlueManager.system_current_time)
  
  return system_current_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_allocated_system_current_time(::std::string* system_current_time) {
  if (system_current_time != NULL) {
    
  } else {
    
  }
  system_current_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_current_time);
  // @@protoc_insertion_point(field_set_allocated:monitor.GlueManager.system_current_time)
}

// optional string process_uptime = 2;
inline void GlueManager::clear_process_uptime() {
  process_uptime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GlueManager::process_uptime() const {
  // @@protoc_insertion_point(field_get:monitor.GlueManager.process_uptime)
  return process_uptime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_process_uptime(const ::std::string& value) {
  
  process_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.GlueManager.process_uptime)
}
inline void GlueManager::set_process_uptime(const char* value) {
  
  process_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.GlueManager.process_uptime)
}
inline void GlueManager::set_process_uptime(const char* value, size_t size) {
  
  process_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.GlueManager.process_uptime)
}
inline ::std::string* GlueManager::mutable_process_uptime() {
  
  // @@protoc_insertion_point(field_mutable:monitor.GlueManager.process_uptime)
  return process_uptime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GlueManager::release_process_uptime() {
  // @@protoc_insertion_point(field_release:monitor.GlueManager.process_uptime)
  
  return process_uptime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_allocated_process_uptime(::std::string* process_uptime) {
  if (process_uptime != NULL) {
    
  } else {
    
  }
  process_uptime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_uptime);
  // @@protoc_insertion_point(field_set_allocated:monitor.GlueManager.process_uptime)
}

// optional string system_uptime = 3;
inline void GlueManager::clear_system_uptime() {
  system_uptime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GlueManager::system_uptime() const {
  // @@protoc_insertion_point(field_get:monitor.GlueManager.system_uptime)
  return system_uptime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_system_uptime(const ::std::string& value) {
  
  system_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.GlueManager.system_uptime)
}
inline void GlueManager::set_system_uptime(const char* value) {
  
  system_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.GlueManager.system_uptime)
}
inline void GlueManager::set_system_uptime(const char* value, size_t size) {
  
  system_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.GlueManager.system_uptime)
}
inline ::std::string* GlueManager::mutable_system_uptime() {
  
  // @@protoc_insertion_point(field_mutable:monitor.GlueManager.system_uptime)
  return system_uptime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GlueManager::release_system_uptime() {
  // @@protoc_insertion_point(field_release:monitor.GlueManager.system_uptime)
  
  return system_uptime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_allocated_system_uptime(::std::string* system_uptime) {
  if (system_uptime != NULL) {
    
  } else {
    
  }
  system_uptime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_uptime);
  // @@protoc_insertion_point(field_set_allocated:monitor.GlueManager.system_uptime)
}

// -------------------------------------------------------------------

// PeerManager

// optional string peer_id = 1;
inline void PeerManager::clear_peer_id() {
  peer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerManager::peer_id() const {
  // @@protoc_insertion_point(field_get:monitor.PeerManager.peer_id)
  return peer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerManager::set_peer_id(const ::std::string& value) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.PeerManager.peer_id)
}
inline void PeerManager::set_peer_id(const char* value) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.PeerManager.peer_id)
}
inline void PeerManager::set_peer_id(const char* value, size_t size) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.PeerManager.peer_id)
}
inline ::std::string* PeerManager::mutable_peer_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.PeerManager.peer_id)
  return peer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerManager::release_peer_id() {
  // @@protoc_insertion_point(field_release:monitor.PeerManager.peer_id)
  
  return peer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerManager::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id != NULL) {
    
  } else {
    
  }
  peer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_id);
  // @@protoc_insertion_point(field_set_allocated:monitor.PeerManager.peer_id)
}

// repeated .monitor.Peer peer = 2;
inline int PeerManager::peer_size() const {
  return peer_.size();
}
inline void PeerManager::clear_peer() {
  peer_.Clear();
}
inline const ::monitor::Peer& PeerManager::peer(int index) const {
  // @@protoc_insertion_point(field_get:monitor.PeerManager.peer)
  return peer_.Get(index);
}
inline ::monitor::Peer* PeerManager::mutable_peer(int index) {
  // @@protoc_insertion_point(field_mutable:monitor.PeerManager.peer)
  return peer_.Mutable(index);
}
inline ::monitor::Peer* PeerManager::add_peer() {
  // @@protoc_insertion_point(field_add:monitor.PeerManager.peer)
  return peer_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::monitor::Peer >*
PeerManager::mutable_peer() {
  // @@protoc_insertion_point(field_mutable_list:monitor.PeerManager.peer)
  return &peer_;
}
inline const ::google::protobuf::RepeatedPtrField< ::monitor::Peer >&
PeerManager::peer() const {
  // @@protoc_insertion_point(field_list:monitor.PeerManager.peer)
  return peer_;
}

// -------------------------------------------------------------------

// BubiStatus

// optional .monitor.GlueManager glue_manager = 1;
inline bool BubiStatus::has_glue_manager() const {
  return !_is_default_instance_ && glue_manager_ != NULL;
}
inline void BubiStatus::clear_glue_manager() {
  if (GetArenaNoVirtual() == NULL && glue_manager_ != NULL) delete glue_manager_;
  glue_manager_ = NULL;
}
inline const ::monitor::GlueManager& BubiStatus::glue_manager() const {
  // @@protoc_insertion_point(field_get:monitor.BubiStatus.glue_manager)
  return glue_manager_ != NULL ? *glue_manager_ : *default_instance_->glue_manager_;
}
inline ::monitor::GlueManager* BubiStatus::mutable_glue_manager() {
  
  if (glue_manager_ == NULL) {
    glue_manager_ = new ::monitor::GlueManager;
  }
  // @@protoc_insertion_point(field_mutable:monitor.BubiStatus.glue_manager)
  return glue_manager_;
}
inline ::monitor::GlueManager* BubiStatus::release_glue_manager() {
  // @@protoc_insertion_point(field_release:monitor.BubiStatus.glue_manager)
  
  ::monitor::GlueManager* temp = glue_manager_;
  glue_manager_ = NULL;
  return temp;
}
inline void BubiStatus::set_allocated_glue_manager(::monitor::GlueManager* glue_manager) {
  delete glue_manager_;
  glue_manager_ = glue_manager;
  if (glue_manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.BubiStatus.glue_manager)
}

// optional .monitor.PeerManager peer_manager = 2;
inline bool BubiStatus::has_peer_manager() const {
  return !_is_default_instance_ && peer_manager_ != NULL;
}
inline void BubiStatus::clear_peer_manager() {
  if (GetArenaNoVirtual() == NULL && peer_manager_ != NULL) delete peer_manager_;
  peer_manager_ = NULL;
}
inline const ::monitor::PeerManager& BubiStatus::peer_manager() const {
  // @@protoc_insertion_point(field_get:monitor.BubiStatus.peer_manager)
  return peer_manager_ != NULL ? *peer_manager_ : *default_instance_->peer_manager_;
}
inline ::monitor::PeerManager* BubiStatus::mutable_peer_manager() {
  
  if (peer_manager_ == NULL) {
    peer_manager_ = new ::monitor::PeerManager;
  }
  // @@protoc_insertion_point(field_mutable:monitor.BubiStatus.peer_manager)
  return peer_manager_;
}
inline ::monitor::PeerManager* BubiStatus::release_peer_manager() {
  // @@protoc_insertion_point(field_release:monitor.BubiStatus.peer_manager)
  
  ::monitor::PeerManager* temp = peer_manager_;
  peer_manager_ = NULL;
  return temp;
}
inline void BubiStatus::set_allocated_peer_manager(::monitor::PeerManager* peer_manager) {
  delete peer_manager_;
  peer_manager_ = peer_manager;
  if (peer_manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.BubiStatus.peer_manager)
}

// -------------------------------------------------------------------

// LedgerStatus

// optional .protocol.LedgerHeader ledger_header = 1;
inline bool LedgerStatus::has_ledger_header() const {
  return !_is_default_instance_ && ledger_header_ != NULL;
}
inline void LedgerStatus::clear_ledger_header() {
  if (GetArenaNoVirtual() == NULL && ledger_header_ != NULL) delete ledger_header_;
  ledger_header_ = NULL;
}
inline const ::protocol::LedgerHeader& LedgerStatus::ledger_header() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.ledger_header)
  return ledger_header_ != NULL ? *ledger_header_ : *default_instance_->ledger_header_;
}
inline ::protocol::LedgerHeader* LedgerStatus::mutable_ledger_header() {
  
  if (ledger_header_ == NULL) {
    ledger_header_ = new ::protocol::LedgerHeader;
  }
  // @@protoc_insertion_point(field_mutable:monitor.LedgerStatus.ledger_header)
  return ledger_header_;
}
inline ::protocol::LedgerHeader* LedgerStatus::release_ledger_header() {
  // @@protoc_insertion_point(field_release:monitor.LedgerStatus.ledger_header)
  
  ::protocol::LedgerHeader* temp = ledger_header_;
  ledger_header_ = NULL;
  return temp;
}
inline void LedgerStatus::set_allocated_ledger_header(::protocol::LedgerHeader* ledger_header) {
  delete ledger_header_;
  ledger_header_ = ledger_header;
  if (ledger_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.LedgerStatus.ledger_header)
}

// optional int64 transaction_size = 2;
inline void LedgerStatus::clear_transaction_size() {
  transaction_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerStatus::transaction_size() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.transaction_size)
  return transaction_size_;
}
inline void LedgerStatus::set_transaction_size(::google::protobuf::int64 value) {
  
  transaction_size_ = value;
  // @@protoc_insertion_point(field_set:monitor.LedgerStatus.transaction_size)
}

// optional int64 account_count = 3;
inline void LedgerStatus::clear_account_count() {
  account_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerStatus::account_count() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.account_count)
  return account_count_;
}
inline void LedgerStatus::set_account_count(::google::protobuf::int64 value) {
  
  account_count_ = value;
  // @@protoc_insertion_point(field_set:monitor.LedgerStatus.account_count)
}

// optional int64 timestamp = 4;
inline void LedgerStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.timestamp)
  return timestamp_;
}
inline void LedgerStatus::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.LedgerStatus.timestamp)
}

// -------------------------------------------------------------------

// SystemProperty

// optional string host_name = 1;
inline void SystemProperty::clear_host_name() {
  host_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemProperty::host_name() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.host_name)
  return host_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_host_name(const ::std::string& value) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.host_name)
}
inline void SystemProperty::set_host_name(const char* value) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemProperty.host_name)
}
inline void SystemProperty::set_host_name(const char* value, size_t size) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemProperty.host_name)
}
inline ::std::string* SystemProperty::mutable_host_name() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemProperty.host_name)
  return host_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemProperty::release_host_name() {
  // @@protoc_insertion_point(field_release:monitor.SystemProperty.host_name)
  
  return host_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_allocated_host_name(::std::string* host_name) {
  if (host_name != NULL) {
    
  } else {
    
  }
  host_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_name);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemProperty.host_name)
}

// optional string os_version = 2;
inline void SystemProperty::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemProperty::os_version() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.os_version)
  return os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_os_version(const ::std::string& value) {
  
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.os_version)
}
inline void SystemProperty::set_os_version(const char* value) {
  
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemProperty.os_version)
}
inline void SystemProperty::set_os_version(const char* value, size_t size) {
  
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemProperty.os_version)
}
inline ::std::string* SystemProperty::mutable_os_version() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemProperty.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemProperty::release_os_version() {
  // @@protoc_insertion_point(field_release:monitor.SystemProperty.os_version)
  
  return os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_allocated_os_version(::std::string* os_version) {
  if (os_version != NULL) {
    
  } else {
    
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemProperty.os_version)
}

// optional int64 startup_time = 3;
inline void SystemProperty::clear_startup_time() {
  startup_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SystemProperty::startup_time() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.startup_time)
  return startup_time_;
}
inline void SystemProperty::set_startup_time(::google::protobuf::int64 value) {
  
  startup_time_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.startup_time)
}

// optional string os_bit = 4;
inline void SystemProperty::clear_os_bit() {
  os_bit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemProperty::os_bit() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.os_bit)
  return os_bit_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_os_bit(const ::std::string& value) {
  
  os_bit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.os_bit)
}
inline void SystemProperty::set_os_bit(const char* value) {
  
  os_bit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemProperty.os_bit)
}
inline void SystemProperty::set_os_bit(const char* value, size_t size) {
  
  os_bit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemProperty.os_bit)
}
inline ::std::string* SystemProperty::mutable_os_bit() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemProperty.os_bit)
  return os_bit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemProperty::release_os_bit() {
  // @@protoc_insertion_point(field_release:monitor.SystemProperty.os_bit)
  
  return os_bit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_allocated_os_bit(::std::string* os_bit) {
  if (os_bit != NULL) {
    
  } else {
    
  }
  os_bit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_bit);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemProperty.os_bit)
}

// -------------------------------------------------------------------

// SystemResource

// optional int64 available = 1;
inline void SystemResource::clear_available() {
  available_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SystemResource::available() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.available)
  return available_;
}
inline void SystemResource::set_available(::google::protobuf::int64 value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemResource.available)
}

// optional int64 total = 2;
inline void SystemResource::clear_total() {
  total_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SystemResource::total() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.total)
  return total_;
}
inline void SystemResource::set_total(::google::protobuf::int64 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemResource.total)
}

// optional double usedPercent = 3;
inline void SystemResource::clear_usedpercent() {
  usedpercent_ = 0;
}
inline double SystemResource::usedpercent() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.usedPercent)
  return usedpercent_;
}
inline void SystemResource::set_usedpercent(double value) {
  
  usedpercent_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemResource.usedPercent)
}

// optional string description = 4;
inline void SystemResource::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemResource::description() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemResource::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemResource.description)
}
inline void SystemResource::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemResource.description)
}
inline void SystemResource::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemResource.description)
}
inline ::std::string* SystemResource::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemResource.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemResource::release_description() {
  // @@protoc_insertion_point(field_release:monitor.SystemResource.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemResource::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemResource.description)
}

// -------------------------------------------------------------------

// Partition

// optional int64 total_bytes = 1;
inline void Partition::clear_total_bytes() {
  total_bytes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Partition::total_bytes() const {
  // @@protoc_insertion_point(field_get:monitor.Partition.total_bytes)
  return total_bytes_;
}
inline void Partition::set_total_bytes(::google::protobuf::int64 value) {
  
  total_bytes_ = value;
  // @@protoc_insertion_point(field_set:monitor.Partition.total_bytes)
}

// repeated .monitor.SystemResource partition = 2;
inline int Partition::partition_size() const {
  return partition_.size();
}
inline void Partition::clear_partition() {
  partition_.Clear();
}
inline const ::monitor::SystemResource& Partition::partition(int index) const {
  // @@protoc_insertion_point(field_get:monitor.Partition.partition)
  return partition_.Get(index);
}
inline ::monitor::SystemResource* Partition::mutable_partition(int index) {
  // @@protoc_insertion_point(field_mutable:monitor.Partition.partition)
  return partition_.Mutable(index);
}
inline ::monitor::SystemResource* Partition::add_partition() {
  // @@protoc_insertion_point(field_add:monitor.Partition.partition)
  return partition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >*
Partition::mutable_partition() {
  // @@protoc_insertion_point(field_mutable_list:monitor.Partition.partition)
  return &partition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >&
Partition::partition() const {
  // @@protoc_insertion_point(field_list:monitor.Partition.partition)
  return partition_;
}

// -------------------------------------------------------------------

// CPU

// optional double usedPercent = 1;
inline void CPU::clear_usedpercent() {
  usedpercent_ = 0;
}
inline double CPU::usedpercent() const {
  // @@protoc_insertion_point(field_get:monitor.CPU.usedPercent)
  return usedpercent_;
}
inline void CPU::set_usedpercent(double value) {
  
  usedpercent_ = value;
  // @@protoc_insertion_point(field_set:monitor.CPU.usedPercent)
}

// -------------------------------------------------------------------

// SystemStatus

// optional .monitor.SystemProperty property = 1;
inline bool SystemStatus::has_property() const {
  return !_is_default_instance_ && property_ != NULL;
}
inline void SystemStatus::clear_property() {
  if (GetArenaNoVirtual() == NULL && property_ != NULL) delete property_;
  property_ = NULL;
}
inline const ::monitor::SystemProperty& SystemStatus::property() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.property)
  return property_ != NULL ? *property_ : *default_instance_->property_;
}
inline ::monitor::SystemProperty* SystemStatus::mutable_property() {
  
  if (property_ == NULL) {
    property_ = new ::monitor::SystemProperty;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.property)
  return property_;
}
inline ::monitor::SystemProperty* SystemStatus::release_property() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.property)
  
  ::monitor::SystemProperty* temp = property_;
  property_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_property(::monitor::SystemProperty* property) {
  delete property_;
  property_ = property;
  if (property) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.property)
}

// optional .monitor.SystemResource memory = 2;
inline bool SystemStatus::has_memory() const {
  return !_is_default_instance_ && memory_ != NULL;
}
inline void SystemStatus::clear_memory() {
  if (GetArenaNoVirtual() == NULL && memory_ != NULL) delete memory_;
  memory_ = NULL;
}
inline const ::monitor::SystemResource& SystemStatus::memory() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.memory)
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
}
inline ::monitor::SystemResource* SystemStatus::mutable_memory() {
  
  if (memory_ == NULL) {
    memory_ = new ::monitor::SystemResource;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.memory)
  return memory_;
}
inline ::monitor::SystemResource* SystemStatus::release_memory() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.memory)
  
  ::monitor::SystemResource* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_memory(::monitor::SystemResource* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.memory)
}

// optional .monitor.CPU cpu = 3;
inline bool SystemStatus::has_cpu() const {
  return !_is_default_instance_ && cpu_ != NULL;
}
inline void SystemStatus::clear_cpu() {
  if (GetArenaNoVirtual() == NULL && cpu_ != NULL) delete cpu_;
  cpu_ = NULL;
}
inline const ::monitor::CPU& SystemStatus::cpu() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.cpu)
  return cpu_ != NULL ? *cpu_ : *default_instance_->cpu_;
}
inline ::monitor::CPU* SystemStatus::mutable_cpu() {
  
  if (cpu_ == NULL) {
    cpu_ = new ::monitor::CPU;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.cpu)
  return cpu_;
}
inline ::monitor::CPU* SystemStatus::release_cpu() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.cpu)
  
  ::monitor::CPU* temp = cpu_;
  cpu_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_cpu(::monitor::CPU* cpu) {
  delete cpu_;
  cpu_ = cpu;
  if (cpu) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.cpu)
}

// optional .monitor.Partition partitions = 4;
inline bool SystemStatus::has_partitions() const {
  return !_is_default_instance_ && partitions_ != NULL;
}
inline void SystemStatus::clear_partitions() {
  if (GetArenaNoVirtual() == NULL && partitions_ != NULL) delete partitions_;
  partitions_ = NULL;
}
inline const ::monitor::Partition& SystemStatus::partitions() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.partitions)
  return partitions_ != NULL ? *partitions_ : *default_instance_->partitions_;
}
inline ::monitor::Partition* SystemStatus::mutable_partitions() {
  
  if (partitions_ == NULL) {
    partitions_ = new ::monitor::Partition;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.partitions)
  return partitions_;
}
inline ::monitor::Partition* SystemStatus::release_partitions() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.partitions)
  
  ::monitor::Partition* temp = partitions_;
  partitions_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_partitions(::monitor::Partition* partitions) {
  delete partitions_;
  partitions_ = partitions;
  if (partitions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.partitions)
}

// -------------------------------------------------------------------

// AlertState

// optional .monitor.AlertState.ALERT_TYPE alert_state = 1;
inline void AlertState::clear_alert_state() {
  alert_state_ = 0;
}
inline ::monitor::AlertState_ALERT_TYPE AlertState::alert_state() const {
  // @@protoc_insertion_point(field_get:monitor.AlertState.alert_state)
  return static_cast< ::monitor::AlertState_ALERT_TYPE >(alert_state_);
}
inline void AlertState::set_alert_state(::monitor::AlertState_ALERT_TYPE value) {
  
  alert_state_ = value;
  // @@protoc_insertion_point(field_set:monitor.AlertState.alert_state)
}

// optional double value = 2;
inline void AlertState::clear_value() {
  value_ = 0;
}
inline double AlertState::value() const {
  // @@protoc_insertion_point(field_get:monitor.AlertState.value)
  return value_;
}
inline void AlertState::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:monitor.AlertState.value)
}

// optional string description = 3;
inline void AlertState::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AlertState::description() const {
  // @@protoc_insertion_point(field_get:monitor.AlertState.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlertState::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.AlertState.description)
}
inline void AlertState::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.AlertState.description)
}
inline void AlertState::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.AlertState.description)
}
inline ::std::string* AlertState::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:monitor.AlertState.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AlertState::release_description() {
  // @@protoc_insertion_point(field_release:monitor.AlertState.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlertState::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:monitor.AlertState.description)
}

// -------------------------------------------------------------------

// AlertStatus

// optional int64 timestamp = 1;
inline void AlertStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AlertStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.AlertStatus.timestamp)
  return timestamp_;
}
inline void AlertStatus::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.AlertStatus.timestamp)
}

// repeated .monitor.AlertState alert_state = 2;
inline int AlertStatus::alert_state_size() const {
  return alert_state_.size();
}
inline void AlertStatus::clear_alert_state() {
  alert_state_.Clear();
}
inline const ::monitor::AlertState& AlertStatus::alert_state(int index) const {
  // @@protoc_insertion_point(field_get:monitor.AlertStatus.alert_state)
  return alert_state_.Get(index);
}
inline ::monitor::AlertState* AlertStatus::mutable_alert_state(int index) {
  // @@protoc_insertion_point(field_mutable:monitor.AlertStatus.alert_state)
  return alert_state_.Mutable(index);
}
inline ::monitor::AlertState* AlertStatus::add_alert_state() {
  // @@protoc_insertion_point(field_add:monitor.AlertStatus.alert_state)
  return alert_state_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::monitor::AlertState >*
AlertStatus::mutable_alert_state() {
  // @@protoc_insertion_point(field_mutable_list:monitor.AlertStatus.alert_state)
  return &alert_state_;
}
inline const ::google::protobuf::RepeatedPtrField< ::monitor::AlertState >&
AlertStatus::alert_state() const {
  // @@protoc_insertion_point(field_list:monitor.AlertStatus.alert_state)
  return alert_state_;
}

// -------------------------------------------------------------------

// ChainAlertMessage

// optional int64 ledger_sequence = 2;
inline void ChainAlertMessage::clear_ledger_sequence() {
  ledger_sequence_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainAlertMessage::ledger_sequence() const {
  // @@protoc_insertion_point(field_get:monitor.ChainAlertMessage.ledger_sequence)
  return ledger_sequence_;
}
inline void ChainAlertMessage::set_ledger_sequence(::google::protobuf::int64 value) {
  
  ledger_sequence_ = value;
  // @@protoc_insertion_point(field_set:monitor.ChainAlertMessage.ledger_sequence)
}

// optional string node_id = 3;
inline void ChainAlertMessage::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainAlertMessage::node_id() const {
  // @@protoc_insertion_point(field_get:monitor.ChainAlertMessage.node_id)
  return node_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainAlertMessage::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.ChainAlertMessage.node_id)
}
inline void ChainAlertMessage::set_node_id(const char* value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.ChainAlertMessage.node_id)
}
inline void ChainAlertMessage::set_node_id(const char* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.ChainAlertMessage.node_id)
}
inline ::std::string* ChainAlertMessage::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.ChainAlertMessage.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainAlertMessage::release_node_id() {
  // @@protoc_insertion_point(field_release:monitor.ChainAlertMessage.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainAlertMessage::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:monitor.ChainAlertMessage.node_id)
}

// optional .monitor.SystemStatus system = 4;
inline bool ChainAlertMessage::has_system() const {
  return !_is_default_instance_ && system_ != NULL;
}
inline void ChainAlertMessage::clear_system() {
  if (GetArenaNoVirtual() == NULL && system_ != NULL) delete system_;
  system_ = NULL;
}
inline const ::monitor::SystemStatus& ChainAlertMessage::system() const {
  // @@protoc_insertion_point(field_get:monitor.ChainAlertMessage.system)
  return system_ != NULL ? *system_ : *default_instance_->system_;
}
inline ::monitor::SystemStatus* ChainAlertMessage::mutable_system() {
  
  if (system_ == NULL) {
    system_ = new ::monitor::SystemStatus;
  }
  // @@protoc_insertion_point(field_mutable:monitor.ChainAlertMessage.system)
  return system_;
}
inline ::monitor::SystemStatus* ChainAlertMessage::release_system() {
  // @@protoc_insertion_point(field_release:monitor.ChainAlertMessage.system)
  
  ::monitor::SystemStatus* temp = system_;
  system_ = NULL;
  return temp;
}
inline void ChainAlertMessage::set_allocated_system(::monitor::SystemStatus* system) {
  delete system_;
  system_ = system;
  if (system) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.ChainAlertMessage.system)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace monitor

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::monitor::AlertState_ALERT_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::monitor::AlertState_ALERT_TYPE>() {
  return ::monitor::AlertState_ALERT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::monitor::MONITOR_MESSAGE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::monitor::MONITOR_MESSAGE_TYPE>() {
  return ::monitor::MONITOR_MESSAGE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::monitor::MONITOR_ERROR> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::monitor::MONITOR_ERROR>() {
  return ::monitor::MONITOR_ERROR_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_monitor_2eproto__INCLUDED
